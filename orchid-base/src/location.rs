//! Structures that show where code or semantic elements came from

use std::fmt;
use std::hash::Hash;
use std::ops::Range;
use std::sync::Arc;

use trait_set::trait_set;

use crate::interner::{deintern, Tok};
use crate::name::Sym;
use crate::{api, sym};

trait_set! {
  pub trait GetSrc = FnMut(&Sym) -> Tok<String>;
}

#[derive(Debug, Clone)]
pub enum Pos {
  None,
  /// Used in functions to denote the generated code that carries on the
  /// location of the call. Not allowed in the const tree.
  Inherit,
  Gen(CodeGenInfo),
  /// Range and file
  SourceRange(SourceRange),
  /// Range only, file implied. Most notably used by parsers
  Range(Range<u32>),
}
impl Pos {
  pub fn to_api(&self) -> api::Location {
    match self {
      Self::Inherit => api::Location::Inherit,
      Self::None => api::Location::None,
      Self::Range(r) => api::Location::Range(r.clone()),
      Self::Gen(cgi) => api::Location::Gen(cgi.to_api()),
      Self::SourceRange(sr) => api::Location::SourceRange(sr.to_api()),
    }
  }
  pub fn from_api(loc: &api::Location) -> Self {
    match loc {
      api::Location::Inherit => Self::Inherit,
      api::Location::None => Self::None,
      api::Location::Range(r) => Self::Range(r.clone()),
      api::Location::Gen(cgi) => CodeGenInfo::from_api(cgi).location(),
      api::Location::SourceRange(sr) => SourceRange::from_api(sr).location(),
    }
  }
  pub fn pretty_print(&self, get_src: &mut impl GetSrc) -> String {
    match self {
      Self::Gen(g) => g.to_string(),
      Self::SourceRange(sr) => sr.pretty_print(&get_src(&sr.path)),
      // Can't pretty print partial and meta-location
      other => format!("{other:?}"),
    }
  }
}

/// Exact source code location. Includes where the code was loaded from, what
/// the original source code was, and a byte range.
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct SourceRange {
  pub(crate) path: Sym,
  pub(crate) range: Range<u32>,
}
impl SourceRange {
  pub fn new(range: &Range<u32>, path: &Sym) -> Self {
    Self { range: range.clone(), path: path.clone() }
  }
  pub fn to_api(&self) -> api::SourceRange {
    api::SourceRange { path: self.path.tok().marker(), range: self.range.clone() }
  }
  pub fn from_api(sr: &api::SourceRange) -> Self {
    Self { path: Sym::from_tok(deintern(sr.path)).unwrap(), range: sr.range.clone() }
  }
  /// Create a dud [SourceRange] for testing. Its value is unspecified and
  /// volatile.
  pub fn mock() -> Self { Self { range: 0..1, path: sym!(test) } }
  /// Path the source text was loaded from
  pub fn path(&self) -> Sym { self.path.clone() }
  /// Byte range
  pub fn range(&self) -> Range<u32> { self.range.clone() }
  /// 0-based index of first byte
  pub fn start(&self) -> u32 { self.range.start }
  /// 0-based index of last byte + 1
  pub fn end(&self) -> u32 { self.range.end }
  /// Syntactic location
  pub fn location(&self) -> Pos { Pos::SourceRange(self.clone()) }
  /// Transform the numeric byte range
  pub fn map_range(&self, map: impl FnOnce(Range<u32>) -> Range<u32>) -> Self {
    Self { range: map(self.range()), path: self.path() }
  }
  pub fn pretty_print(&self, src: &str) -> String {
    let (sl, sc) = pos2lc(src, self.range.start);
    let (el, ec) = pos2lc(src, self.range.end);
    match (el == sl, ec <= sc + 1) {
      (true, true) => format!("{sl}:{sc}"),
      (true, false) => format!("{sl}:{sc}..{ec}"),
      (false, _) => format!("{sl}:{sc}..{el}:{ec}"),
    }
  }
}

/// Information about a code generator attached to the generated code
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct CodeGenInfo {
  /// formatted like a Rust namespace
  pub generator: Sym,
  /// Unformatted user message with relevant circumstances and parameters
  pub details: Arc<String>,
}
impl CodeGenInfo {
  /// A codegen marker with no user message and parameters
  pub fn no_details(generator: Sym) -> Self { Self { generator, details: Arc::new(String::new()) } }
  /// A codegen marker with a user message or parameters
  pub fn details(generator: Sym, details: impl AsRef<str>) -> Self {
    Self { generator, details: Arc::new(details.as_ref().to_string()) }
  }
  /// Syntactic location
  pub fn location(&self) -> Pos { Pos::Gen(self.clone()) }
  pub fn to_api(&self) -> api::CodeGenInfo {
    api::CodeGenInfo { generator: self.generator.tok().marker(), details: self.details.to_string() }
  }
  pub fn from_api(cgi: &api::CodeGenInfo) -> Self {
    Self {
      generator: Sym::from_tok(deintern(cgi.generator)).unwrap(),
      details: Arc::new(cgi.details.clone()),
    }
  }
}
impl fmt::Debug for CodeGenInfo {
  fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result { write!(f, "CodeGenInfo({self})") }
}
impl fmt::Display for CodeGenInfo {
  fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
    write!(f, "generated by {}", self.generator)?;
    if !self.details.is_empty() { write!(f, ", details: {}", self.details) } else { write!(f, ".") }
  }
}

#[must_use]
fn pos2lc(s: &str, i: u32) -> (u32, u32) {
  s.chars()
    .take(i.try_into().unwrap())
    .fold((1, 1), |(line, col), char| if char == '\n' { (line + 1, 1) } else { (line, col + 1) })
}
