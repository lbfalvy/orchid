//! Datastructures used to define an Orchid project

use std::fmt::Display;
use std::sync::Arc;

use hashbrown::{HashMap, HashSet};
use intern_all::Tok;
use itertools::Itertools;
use never::Never;
use ordered_float::NotNan;
use substack::Substack;

use crate::location::{CodeLocation, SourceRange};
use crate::name::Sym;
use crate::parse::numeric::print_nat16;
use crate::parse::parsed::{Clause, Expr};
use crate::tree::{ModEntry, ModMember, Module, ModMemberRef};
use crate::utils::combine::Combine;
use crate::utils::unwrap_or::unwrap_or;

/// Different elements that can appear in a module other than submodules
#[derive(Debug, Clone)]
pub enum ItemKind {
  /// An imported symbol or module. The value is the absolute path of
  /// the symbol that should be used instead of this one.
  Alias(Sym),
  /// This name is only used in macros
  None,
  /// This name has a value associated with it
  Const(Expr),
}

impl Default for ItemKind {
  fn default() -> Self { Self::None }
}

/// Element in a module
#[derive(Debug, Clone)]
pub struct ProjItem {
  /// The nature of the element
  pub kind: ItemKind,
}

impl Default for ProjItem {
  fn default() -> Self { Self { kind: ItemKind::None } }
}

impl Display for ProjItem {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    match &self.kind {
      ItemKind::None => write!(f, "keyword"),
      ItemKind::Const(c) => write!(f, "constant {c}"),
      ItemKind::Alias(alias) => write!(f, "alias to {alias}"),
    }
  }
}

impl Combine for ProjItem {
  type Error = Never;
  fn combine(self, _: Self) -> Result<Self, Self::Error> {
    unimplemented!("Only implied project modules can be merged, not items")
  }
}

/// A substitution rule as stored in the tree
#[derive(Debug, Clone)]
pub struct ProjRule {
  /// Tree fragment in the source code that activates this rule
  pub pattern: Vec<Expr>,
  /// Influences the order in which rules are checked
  pub prio: NotNan<f64>,
  /// Tree fragment generated by this rule
  pub template: Vec<Expr>,
  /// Comments associated with this rule
  pub comments: Vec<Arc<String>>,
}

impl ProjRule {
  /// Namespace all tokens in the rule
  #[must_use]
  pub fn prefix(
    self,
    prefix: &[Tok<String>],
    except: &impl Fn(Tok<String>) -> bool,
  ) -> Self {
    let Self { comments, prio, mut pattern, mut template } = self;
    (pattern.iter_mut())
      .chain(template.iter_mut())
      .for_each(|e| *e = e.prefix(prefix, except));
    Self { prio, comments, pattern, template }
  }

  /// Return a list of all names that don't contain a namespace separator `::`.
  /// These are exported when the rule is exported
  #[must_use]
  pub fn collect_root_names(&self) -> HashSet<Tok<String>> {
    let mut names = HashSet::new();
    for e in self.pattern.iter() {
      e.search_all(&mut |e| {
        if let Clause::Name(ns_name) = &e.value {
          names.extend(ns_name[..].iter().exactly_one().ok().cloned())
        }
        None::<()>
      });
    }
    names
  }
}

impl Display for ProjRule {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    write!(
      f,
      "{}rule {} ={}=> {}",
      self.comments.iter().map(|s| format!("--[{s}]--\n")).join(""),
      self.pattern.iter().join(" "),
      print_nat16(self.prio),
      self.template.iter().join(" ")
    )
  }
}

/// Information about a module that is defined in a source file
#[derive(Clone, Debug)]
pub struct SourceModule {
  /// All rules defined in this module, exported or not
  pub rules: Vec<ProjRule>,
  /// Location of this module.
  pub range: SourceRange,
}

/// Additional data about a loaded module beyond the list of constants and
/// submodules
#[derive(Clone, Debug, Default)]
pub struct ProjXMod {
  /// Details only available for a module loaded from a source file
  pub src: Option<SourceModule>,
}

impl Combine for ProjXMod {
  type Error = Never;
  fn combine(self, other: Self) -> Result<Self, Self::Error> {
    match (self.src, other.src) {
      (None, None) => Ok(Self { src: None }),
      (..) => panic!("Only implied modules can be merged"),
    }
  }
}

/// Information about a module entry
#[derive(Clone, Debug)]
pub struct ProjXEnt {
  /// All comments appearing above the item or submodule
  pub comments: Vec<Arc<String>>,
  /// Whether the member is visible to modules other than the parent
  pub exported: bool,
  /// Location of this item
  pub locations: Vec<CodeLocation>,
}
impl Default for ProjXEnt {
  fn default() -> Self {
    Self { comments: vec![], exported: true, locations: vec![] }
  }
}
impl ProjXEnt {
  /// Implied modules can be merged easily. It's difficult to detect whether
  /// a module is implied so we just assert that it doesn't have an associated
  /// source location
  pub fn is_default(&self) -> bool { self.locations.is_empty() }
}
impl Combine for ProjXEnt {
  type Error = MergingFiles;
  fn combine(self, other: Self) -> Result<Self, Self::Error> {
    (self.is_default() && other.is_default())
      .then_some(self)
      .ok_or(MergingFiles)
  }
}

/// Error produced when a module defined in a file has an alternate definition
/// in another file or as a folder. This is explicitly banned because
/// implementing a good version of it would require undue complexity
#[derive(Debug, Clone, Copy, Default, Hash, PartialEq, Eq)]
pub struct MergingFiles;

impl Display for ProjXMod {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut dbg = f.debug_struct("ProjectExt");
    match &self.src {
      None => dbg.finish_non_exhaustive(),
      Some(SourceModule { rules, range }) =>
        dbg.field("rules", &rules).field("range", &range).finish(),
    }
  }
}

/// A child to a [ProjectMod]
pub type ProjectEntry = ModEntry<ProjItem, ProjXMod, ProjXEnt>;
/// A node in the tree describing the project
pub type ProjectMod = Module<ProjItem, ProjXMod, ProjXEnt>;
/// A reference to an item or module in the project
pub type ProjectMemberRef<'a> = ModMemberRef<'a, ProjItem, ProjXMod, ProjXEnt>;

fn collect_rules_rec(bag: &mut Vec<ProjRule>, module: &ProjectMod) {
  bag.extend(module.x.src.iter().flat_map(|s| &s.rules).cloned());
  for item in module.entries.values() {
    if let ModMember::Sub(module) = &item.member {
      collect_rules_rec(bag, module);
    }
  }
}
fn collect_consts_rec(
  path: Substack<Tok<String>>,
  bag: &mut HashMap<Sym, ConstReport>,
  module: &ProjectMod,
) {
  for (key, entry) in module.entries.iter() {
    match &entry.member {
      ModMember::Item(it) =>
        if let ItemKind::Const(expr) = &it.kind {
          let name = path.push(key.clone()).iter().unreverse();
          let name = Sym::new(name).expect("pushed above");
          let location =
            entry.x.locations.first().cloned().unwrap_or_else(|| {
              panic!("{name} is a const in source, yet it has no location")
            });
          let range = unwrap_or!(location => CodeLocation::Source; {
            panic!("{name} is a const in source, yet its \
            location is generated")
          });
          bag.insert(name, ConstReport {
            comments: entry.x.comments.clone(),
            value: expr.clone(),
            range,
          });
        },
      ModMember::Sub(module) =>
        collect_consts_rec(path.push(key.clone()), bag, module),
    }
  }
}

/// Module corresponding to the root of a project
#[derive(Debug, Clone)]
pub struct ProjectTree(pub ProjectMod);
impl ProjectTree {
  /// Collect the complete list of rules to be used by the rule repository
  #[must_use]
  pub fn all_rules(&self) -> Vec<ProjRule> {
    let mut rules = Vec::new();
    collect_rules_rec(&mut rules, &self.0);
    rules
  }

  /// Extract the symbol table
  #[must_use]
  pub fn all_consts(&self) -> HashMap<Sym, ConstReport> {
    let mut consts = HashMap::new();
    collect_consts_rec(Substack::Bottom, &mut consts, &self.0);
    consts
  }
}

/// Information about a constant
#[derive(Clone, Debug)]
pub struct ConstReport {
  /// Operational comments
  pub comments: Vec<Arc<String>>,
  /// Value assigned to the constant
  pub value: Expr,
  /// Source location this constant was parsed from
  pub range: SourceRange,
}
