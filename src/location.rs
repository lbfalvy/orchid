//! Structures that show where code or semantic elements came from

use std::fmt;
use std::hash::Hash;
use std::ops::Range;
use std::sync::Arc;

use itertools::Itertools;

use crate::name::{NameLike, Sym};
use crate::sym;

/// A full source code unit, such as a source file
#[derive(Clone, Eq)]
pub struct SourceCode {
  pub(crate) path: Sym,
  pub(crate) text: Arc<String>,
}
impl SourceCode {
  /// Create a new source file description
  pub fn new(path: Sym, source: Arc<String>) -> Self { Self { path, text: source } }
  /// Location the source code was loaded from in the virtual tree
  pub fn path(&self) -> Sym { self.path.clone() }
  /// Raw source code string
  pub fn text(&self) -> Arc<String> { self.text.clone() }
}
impl PartialEq for SourceCode {
  fn eq(&self, other: &Self) -> bool { self.path == other.path }
}
impl Hash for SourceCode {
  fn hash<H: std::hash::Hasher>(&self, state: &mut H) { self.path.hash(state) }
}
impl fmt::Debug for SourceCode {
  fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result { write!(f, "CodeInfo({self})") }
}
impl fmt::Display for SourceCode {
  fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
    write!(f, "{}.orc", self.path.str_iter().join("/"))
  }
}
impl AsRef<str> for SourceCode {
  fn as_ref(&self) -> &str { &self.text }
}

/// Exact source code location. Includes where the code was loaded from, what
/// the original source code was, and a byte range.
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct SourceRange {
  pub(crate) code: SourceCode,
  pub(crate) range: Range<usize>,
}
impl SourceRange {
  /// Create a dud [SourceRange] for testing. Its value is unspecified and
  /// volatile.
  pub fn mock() -> Self {
    let code = SourceCode { path: sym!(test), text: Arc::new(String::new()) };
    SourceRange { range: 0..1, code }
  }
  /// Source code
  pub fn code(&self) -> SourceCode { self.code.clone() }
  /// Source text
  pub fn text(&self) -> Arc<String> { self.code.text.clone() }
  /// Path the source text was loaded from
  pub fn path(&self) -> Sym { self.code.path.clone() }
  /// Byte range
  pub fn range(&self) -> Range<usize> { self.range.clone() }
  /// Syntactic location
  pub fn origin(&self) -> CodeOrigin { CodeOrigin::Source(self.clone()) }
  /// Transform the numeric byte range
  pub fn map_range(&self, map: impl FnOnce(Range<usize>) -> Range<usize>) -> Self {
    Self { code: self.code(), range: map(self.range()) }
  }
}
impl fmt::Debug for SourceRange {
  fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result { write!(f, "CodeRange({self})") }
}
impl fmt::Display for SourceRange {
  fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
    let Self { code, range } = self;
    let (sl, sc) = pos2lc(code.text.as_str(), range.start);
    let (el, ec) = pos2lc(code.text.as_str(), range.end);
    write!(f, "{code} {sl}:{sc}")?;
    if el == sl {
      if sc + 1 == ec { Ok(()) } else { write!(f, "..{ec}") }
    } else {
      write!(f, "..{el}:{ec}")
    }
  }
}

/// Information about a code generator attached to the generated code
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct CodeGenInfo {
  /// formatted like a Rust namespace
  pub generator: Sym,
  /// Unformatted user message with relevant circumstances and parameters
  pub details: Arc<String>,
}
impl CodeGenInfo {
  /// A codegen marker with no user message and parameters
  pub fn no_details(generator: Sym) -> Self { Self { generator, details: Arc::new(String::new()) } }
  /// A codegen marker with a user message or parameters
  pub fn details(generator: Sym, details: impl AsRef<str>) -> Self {
    Self { generator, details: Arc::new(details.as_ref().to_string()) }
  }
}
impl fmt::Debug for CodeGenInfo {
  fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result { write!(f, "CodeGenInfo({self})") }
}
impl fmt::Display for CodeGenInfo {
  fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
    write!(f, "generated by {}", self.generator)?;
    if !self.details.is_empty() { write!(f, ", details: {}", self.details) } else { write!(f, ".") }
  }
}

/// identifies a sequence of characters that contributed to the enclosing
/// construct or the reason the code was generated for generated code.
#[derive(Clone, PartialEq, Eq, Hash)]
pub enum CodeOrigin {
  /// Character sequence
  Source(SourceRange),
  /// Generated construct
  Gen(CodeGenInfo),
}

impl fmt::Display for CodeOrigin {
  fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
    match self {
      Self::Gen(info) => write!(f, "{info}"),
      Self::Source(cr) => write!(f, "{cr}"),
    }
  }
}

impl fmt::Debug for CodeOrigin {
  fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result { write!(f, "CodeOrigin({self})") }
}

/// Location data associated with any code fragment. Identifies where the code
/// came from and where it resides in the tree.
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct CodeLocation {
  pub(crate) origin: CodeOrigin,
  pub(crate) module: Sym,
}
impl CodeLocation {
  pub(crate) fn new_src(range: SourceRange, module: Sym) -> Self {
    Self { origin: CodeOrigin::Source(range), module }
  }
  /// Create a location for generated code. The generator string must not be
  /// empty. For code, the generator string must contain at least one `::`
  pub fn new_gen(gen: CodeGenInfo) -> Self {
    Self { module: gen.generator.clone(), origin: CodeOrigin::Gen(gen) }
  }

  /// Get the syntactic location
  pub fn origin(&self) -> CodeOrigin { self.origin.clone() }
  /// Get the name of the containing module
  pub fn module(&self) -> Sym { self.module.clone() }
}

impl fmt::Display for CodeLocation {
  fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
    if self.module[..].is_empty() {
      write!(f, "global {}", self.origin)
    } else {
      write!(f, "{} in {}", self.origin, self.module)
    }
  }
}

impl fmt::Debug for CodeLocation {
  fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result { write!(f, "CodeLocation({self})") }
}

#[must_use]
fn pos2lc(s: &str, i: usize) -> (usize, usize) {
  s.chars().take(i).fold(
    (1, 1),
    |(line, col), char| {
      if char == '\n' { (line + 1, 1) } else { (line, col + 1) }
    },
  )
}
