use std::fmt::{Debug, Display};
use std::hash::Hash;
use std::ops::Range;
use std::sync::Arc;

use itertools::Itertools;

use crate::name::VPath;

/// A full source code unit, such as a source file
#[derive(Clone, Eq)]
pub struct SourceCode {
  /// Location the source code was loaded from in the virtual tree
  pub path: Arc<VPath>,
  /// Raw source code string
  pub source: Arc<String>,
}
impl PartialEq for SourceCode {
  fn eq(&self, other: &Self) -> bool { self.path == other.path }
}
impl Hash for SourceCode {
  fn hash<H: std::hash::Hasher>(&self, state: &mut H) { self.path.hash(state) }
}
impl Debug for SourceCode {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    write!(f, "CodeInfo({self})")
  }
}
impl Display for SourceCode {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    write!(f, "{}.orc", self.path.str_iter().join("/"))
  }
}

/// Exact source code location. Includes where the code was loaded from, what
/// the original source code was, and a byte range.
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct SourceRange {
  /// Source code
  pub code: SourceCode,
  /// Byte range
  pub range: Range<usize>,
}
impl SourceRange {
  /// Transform the numeric byte range
  pub fn map_range(
    &self,
    map: impl FnOnce(Range<usize>) -> Range<usize>,
  ) -> Self {
    Self { code: self.code.clone(), range: map(self.range.clone()) }
  }
}
impl Debug for SourceRange {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    write!(f, "CodeRange({} {:?})", self.code, self.range)
  }
}
impl Display for SourceRange {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let Self { code, range } = self;
    let (sl, sc) = pos2lc(code.source.as_str(), range.start);
    let (el, ec) = pos2lc(code.source.as_str(), range.end);
    write!(f, "{code} {sl}:{sc}")?;
    if el == sl {
      if sc + 1 == ec { Ok(()) } else { write!(f, "..{ec}") }
    } else {
      write!(f, "..{el}:{ec}")
    }
  }
}

/// Information about a code generator attached to the generated code
#[derive(Clone, PartialEq, Eq, Hash)]
pub struct CodeGenInfo {
  /// formatted like a Rust namespace
  pub generator: &'static str,
  /// Unformatted user message with relevant circumstances and parameters
  pub details: Arc<String>,
}
impl CodeGenInfo {
  /// A codegen marker with no user message and parameters
  pub fn no_details(generator: &'static str) -> Self {
    Self { generator, details: Arc::new(String::new()) }
  }
  /// A codegen marker with a user message or parameters
  pub fn details(generator: &'static str, details: impl AsRef<str>) -> Self {
    Self { generator, details: Arc::new(details.as_ref().to_string()) }
  }
}
impl Debug for CodeGenInfo {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    write!(f, "CodeGenInfo({self})")
  }
}
impl Display for CodeGenInfo {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    write!(f, "generated by {}", self.generator)?;
    if !self.details.is_empty() {
      write!(f, ", details: {}", self.details)
    } else {
      write!(f, ".")
    }
  }
}

/// A location for error reporting. In the context of an error, identifies a
/// sequence of suspect characters or the reason the code was generated for
/// generated code. Meaningful within the context of a project.
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum CodeLocation {
  /// Character sequence
  Source(SourceRange),
  /// Generated construct
  Gen(CodeGenInfo),
}

impl Display for CodeLocation {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    match self {
      Self::Gen(info) => write!(f, "{info}"),
      Self::Source(cr) => write!(f, "{cr}"),
    }
  }
}

#[must_use]
fn pos2lc(s: &str, i: usize) -> (usize, usize) {
  s.chars().take(i).fold((1, 1), |(line, col), char| {
    if char == '\n' { (line + 1, 1) } else { (line, col + 1) }
  })
}
